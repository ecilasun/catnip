
    // Parameter mode
    /*while(state == PS_Parameters)
    {
        // 0) end of parameter list
        {
            bool is_endstatement = _tokenTable[currentToken].m_Type == TK_EndParams;
            if (is_endstatement)
            {
                state = PS_Statement;
                ++currentToken;
                return;
            }
        }

        // 1) parameter entry
        bool is_typename = _tokenTable[currentToken].m_Type == TK_Typename;
        bool is_identifier = _tokenTable[currentToken+1].m_Type == TK_Identifier;
        if (is_typename, is_identifier)
        {
            SASTNode node;
            // Self is variable name
            node.m_Self.m_Value = "PARAM";
            node.m_Self.m_Type = NT_VariableDeclaration;
            // Type on left node
            node.m_Left = new SASTNode();
            node.m_Left->m_Self.m_Value = _tokenTable[currentToken].m_Value;
            node.m_Left->m_Self.m_Type = NT_TypeName;
            // Identifier on right node
            node.m_Right = new SASTNode();
            node.m_Right->m_Self.m_Value = _tokenTable[currentToken+1].m_Value;
            node.m_Right->m_Self.m_Type = NT_Identifier;
            // Store
            _ast.emplace_back(node);
            currentToken += 2;
        }
        else
            ++currentToken;
    }*/

    // Statement mode
    //if (state == PS_Statement)
    {
        // 0) identifier (
        // or builtin (
        /*{
            bool is_identifier = _tokenTable[currentToken].m_Type == TK_Identifier;
            bool is_builtin = _tokenTable[currentToken].m_Type == TK_Keyword;
            bool is_beginparams = _tokenTable[currentToken+1].m_Type == TK_BeginParams;
            if ((is_identifier||is_builtin) && is_beginparams)
            {
                SASTNode nodeCall;
                // Self is variable name
                nodeCall.m_Self.m_Value = "FUNCCALL";
                nodeCall.m_Self.m_Type = NT_VariableDeclaration;
                // Type on left node
                nodeCall.m_Left = new SASTNode();
                nodeCall.m_Left->m_Self.m_Value = _tokenTable[currentToken].m_Value;
                nodeCall.m_Left->m_Self.m_Type = NT_TypeName;
                // Parameters on right node (comma separated, not evaluated)
                nodeCall.m_Right = new SASTNode();
                state = PS_ExpressionParamList;
                currentToken+=2; // Skip identifier and beginparams
                ParseAndGenerateAST(_tokenTable, _ast, state, currentToken, nodeCall.m_Right);
                // Store
                _ast.emplace_back(nodeCall);

                return;
            }
        }*/

        // 1) identifier =
        /*{
            bool is_identifier = _tokenTable[currentToken].m_Type == TK_Identifier;
            bool is_assignop = _tokenTable[currentToken+1].m_Type == TK_OpAssignment;
            if (is_identifier && is_assignop)
            {
                SASTNode nodeAssign;
                nodeAssign.m_Self.m_Value = "ASSIGN";
                nodeAssign.m_Self.m_Type = NT_OpAssignment;
                // Left: identifier
                nodeAssign.m_Left = new SASTNode();
                nodeAssign.m_Left->m_Self.m_Value = _tokenTable[currentToken].m_Value;
                nodeAssign.m_Left->m_Self.m_Type = NT_Identifier;
                // Right: Resume parsing expression into right node
                nodeAssign.m_Right = new SASTNode();
                state = PS_Expression;
                currentToken+=2; // Skip identifier and assignment operator and parse the expression
                ParseAndGenerateAST(_tokenTable, _ast, state, currentToken, nodeAssign.m_Right);
                // Store
                _ast.emplace_back(nodeAssign);
            }
        }*/

        // 2) identifier [ expression ] = expression;

        // 3) typename identifier
        /*{
            bool is_typename = _tokenTable[currentToken].m_Type == TK_Typename;
            bool is_identifier = _tokenTable[currentToken+1].m_Type == TK_Identifier;

            if (is_typename && is_identifier)
            {
                // This is a function declaration if it's of the form: typename identifier (
                bool is_functiondecl = _tokenTable[currentToken+2].m_Type == TK_BeginParams;

                // DECL(typename, identifier) or FUNC(typename, identifier)
                SASTNode node;
                // Self is variable name
                node.m_Self.m_Value = is_functiondecl ? "FUNCDEF" : "VARDECL";
                node.m_Self.m_Type = NT_VariableDeclaration;
                // Type on left node
                node.m_Left = new SASTNode();
                node.m_Left->m_Self.m_Value = _tokenTable[currentToken].m_Value;
                node.m_Left->m_Self.m_Type = NT_TypeName;
                // Element count on left of left node
                node.m_Left->m_Left = new SASTNode();
                node.m_Left->m_Left->m_Self.m_Value = "1";
                node.m_Left->m_Left->m_Self.m_Type = NT_LiteralConstant;
                // Identifier on right node
                node.m_Right = new SASTNode();
                node.m_Right->m_Self.m_Value = _tokenTable[currentToken+1].m_Value;
                node.m_Right->m_Self.m_Type = NT_Identifier;
                // Store
                _ast.emplace_back(node);
                currentToken += 2;

                // TODO: Jump into parameter parse mode
                if (is_functiondecl)
                {
                    state = PS_Parameters;
                    return;
                }

                // expected ; or , or )
                bool is_endstatement = _tokenTable[currentToken].m_Type == TK_EndStatement;
                // or expected =
                bool is_assignment = _tokenTable[currentToken].m_Type == TK_OpAssignment;
                // or expected [
                bool is_beginarray = _tokenTable[currentToken].m_Type == TK_BeginArray;
                // or expected (
                bool is_beginparams = _tokenTable[currentToken].m_Type == TK_BeginParams;

                // typename identifier ;
                if (is_endstatement)
                {
                    // Advance
                    currentToken++;
                    return;
                }

                // Update array size
                std::string variableName = "";
                if (is_beginarray)
                {
                    node.m_Left->m_Left->m_Self.m_Value = _tokenTable[currentToken+1].m_Value;
                    currentToken+=3;
                    is_assignment = _tokenTable[currentToken].m_Type == TK_OpAssignment;
                    variableName = _tokenTable[currentToken-4].m_Value;
                }
                else
                {
                    variableName = _tokenTable[currentToken-1].m_Value;
                }
                

                // typename identifier = expression ;
                if (is_assignment)
                {
                    // ASSIGN(identifier, expression)
                    SASTNode nodeAssign;
                    nodeAssign.m_Self.m_Value = "ASSIGN";
                    nodeAssign.m_Self.m_Type = NT_OpAssignment;
                    // Left: identifier
                    nodeAssign.m_Left = new SASTNode();
                    nodeAssign.m_Left->m_Self.m_Value = variableName;
                    nodeAssign.m_Left->m_Self.m_Type = NT_Identifier;
                    // Right: Resume parsing expression into right node
                    nodeAssign.m_Right = new SASTNode();
                    state = PS_Expression;
                    currentToken++; // Skip assignment operator and parse the expression
                    ParseAndGenerateAST(_tokenTable, _ast, state, currentToken, nodeAssign.m_Right);
                    // Store
                    _ast.emplace_back(nodeAssign);

                    return;
                }
            }
        }

        // Unknown
        {
            ++currentToken;
            return;
        }
    }*/

    /*while (state == PS_Expression || state == PS_ExpressionParamList)
    {
        // 0) end of statement
        {
            bool is_endstatement = (state == PS_ExpressionParamList) ? false : _tokenTable[currentToken].m_Type == TK_EndStatement;
            bool is_endparams = _tokenTable[currentToken].m_Type == TK_EndParams;
            bool is_endarray = _tokenTable[currentToken].m_Type == TK_EndArray;
            if (is_endstatement || is_endparams || is_endarray)
            {
                state = PS_Statement;
                ++currentToken;
                return;
            }
        }

        // 1) expression term
        {
            bool is_separator = _tokenTable[currentToken].m_Type == TK_Separator;
            bool is_beginblock = _tokenTable[currentToken].m_Type == TK_BeginBlock;
            bool is_endblock = _tokenTable[currentToken].m_Type == TK_EndBlock;
            if (!is_separator && !is_beginblock && !is_endblock)
            {
                if (!_payload)
                {
                    std::cout << "ERROR: Found standalone expression" << std::endl;
                    return;
                }

                _payload->m_Self.m_Value += _tokenTable[currentToken].m_Value + " ";
                _payload->m_Self.m_Type = NT_LiteralConstant;
            }
        }

        ++currentToken;
    }*/